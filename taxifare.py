# -*- coding: utf-8 -*-
"""taxifare.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zX6bsv9H3_uqYZJU4mpA71k-4PTLwyF1
"""

# Commented out IPython magic to ensure Python compatibility.
# For processing the data
import numpy as np
import pandas as pd
import datetime as dt

# Visualization tools
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
sns.set_style("white") # set style for seaborn plots

# Machine learning
from sklearn.model_selection import train_test_split
import xgboost as xgb

# Ignore warnings
import warnings 
warnings.filterwarnings('ignore')

# Time-related functions
import time

data = pd.read_csv("taxi_fare_submission.csv", nrows = 7000000)

print("Dimensions of our training set: ", data.shape)
data.dtypes

data.head()

f, ax = plt.subplots(1, 1, figsize=(8,5))
sns.distplot(data["fare_amount"], kde=True, color="#fdb813")
plt.xlim(0, 700)
plt.ylim(0, 0.08)
plt.title("Distribution of the target: fare_amount")
plt.xlabel("Frequency")
plt.show()

q1  = data['fare_amount'].quantile(0.25)
q3  = data['fare_amount'].quantile(0.75)
iqr =  q3 - q1
print("Fare Amount lower bound : ", q1 - (1.5 * iqr), 
      "Fare Amount upper bound : ", q3 + (1.5 * iqr))

print("Total null values:\n", data.isnull().sum())
print("Percentage of null values:\n",
      data[["dropoff_longitude", "dropoff_latitude"]].isnull().sum() / data.shape[0])

data.dropna(how='any', axis='rows', inplace=True)

f, ax = plt.subplots(1, 2, figsize=(16, 5))
sns.scatterplot(x="pickup_longitude", y="pickup_latitude", data=data.iloc[:10000], 
                color="#fdb813", ax=ax[0])
sns.scatterplot(x="dropoff_longitude", y="dropoff_latitude", data=data.iloc[:10000], 
                color="#fdb813", ax=ax[1])
ax[0].set_title("Pickup Coordinates")
ax[1].set_title("Dropoff Coordinates")
plt.show()

data.describe()

def get_cleaned(df):
    return df[(df.fare_amount > 0) &
              (df.pickup_latitude > 35) & (df.pickup_latitude < 45) &
              (df.pickup_longitude > -80) & (df.pickup_longitude < -68) &
              (df.dropoff_latitude > 35) & (df.dropoff_latitude < 45) &
              (df.pickup_longitude > -80) & (df.dropoff_longitude < -68) &
              (df.passenger_count > 0) & (df.passenger_count < 8)]

data = get_cleaned(data)
print(len(data))
print("Data lost after the cleaning process: ", 7000000 - len(data))

def sphere_dist(pick_lat, pick_lon, drop_lat, drop_lon):
    R_earth = 6371 # Earth radius (in km)
    # Convert degrees to radians
    pick_lat, pick_lon, drop_lat, drop_lon = map(np.radians, [pick_lat, pick_lon,
                                                              drop_lat, drop_lon])
    # Compute distances along lat, lon dimensions
    dlat = drop_lat - pick_lat
    dlon = drop_lon - pick_lon
    
    # Compute haversine distance
    a = np.sin(dlat/2.0)**2 + np.cos(pick_lat) * np.cos(drop_lat) * np.sin(dlon/2.0)**2
    return 2 * R_earth * np.arcsin(np.sqrt(a))

def airport_dist(df):
    """
    JFK: John F. Kennedy International Airport
    EWR: Newark Liberty International Airport
    LGA: LaGuardia Airport
    """
    jfk_coord = (40.639722, -73.778889)
    ewr_coord = (40.6925, -74.168611)
    lga_coord = (40.77725, -73.872611)
    
    pick_lat = df['pickup_latitude']
    pick_lon = df['pickup_longitude']
    drop_lat = df['dropoff_latitude']
    drop_lon = df['dropoff_longitude']
    
    pickup_jfk = sphere_dist(pick_lat, pick_lon, jfk_coord[0], jfk_coord[1])
    dropoff_jfk = sphere_dist(jfk_coord[0], jfk_coord[1], drop_lat, drop_lon) 
    pickup_ewr = sphere_dist(pick_lat, pick_lon, ewr_coord[0], ewr_coord[1])
    dropoff_ewr = sphere_dist(ewr_coord[0], ewr_coord[1], drop_lat, drop_lon) 
    pickup_lga = sphere_dist(pick_lat, pick_lon, lga_coord[0], lga_coord[1]) 
    dropoff_lga = sphere_dist(lga_coord[0], lga_coord[1], drop_lat, drop_lon)
    
    df['jfk_dist'] = pd.concat([pickup_jfk, dropoff_jfk], axis=1).min(axis=1)
    df['ewr_dist'] = pd.concat([pickup_ewr, dropoff_ewr], axis=1).min(axis=1)
    df['lga_dist'] = pd.concat([pickup_lga, dropoff_lga], axis=1).min(axis=1)
    
    return df

def datetime_info(df):
    #Convert to datetime format
    df['pickup_datetime'] = pd.to_datetime(df['pickup_datetime'],format="%Y-%m-%d %H:%M:%S UTC")
    
    df['hour'] = df.pickup_datetime.dt.hour
    df['day'] = df.pickup_datetime.dt.day
    df['month'] = df.pickup_datetime.dt.month
    df['weekday'] = df.pickup_datetime.dt.weekday
    df['year'] = df.pickup_datetime.dt.year
    
    return df


data = datetime_info(data)
data = airport_dist(data)
data['distance'] = sphere_dist(data['pickup_latitude'], data['pickup_longitude'], 
                               data['dropoff_latitude'], data['dropoff_longitude'])

data.head()

plt.figure(figsize=(10,5))
sns.lineplot(x="year", y="fare_amount", data=data, color="#fdb813")
plt.title("Fare among years")
plt.show()

f, ax = plt.subplots(1, 2, figsize=(12,5))
ax[0].hist(data["passenger_count"], bins=7, color=("#fdb813"))
ax[0].set_title("Number of passengers frequency")
ax[0].set_xlabel('No. of Passengers')
ax[0].set_ylabel('Frequency')

ax[1].scatter(x=data["passenger_count"], y=data["fare_amount"], s=1.5, 
              color=("#3D2C05"))
ax[1].set_title("Fare amount by number of passengers")
ax[1].set_xlabel('No. of Passengers')
ax[1].set_ylabel('Fare');

f, ax = plt.subplots(1, 3, figsize=(16,5))
ax[0].hist(data["hour"], bins=24, color="#fdb813")
ax[0].set_title("Frequency of rides by Hour of the day")
ax[0].set_xlabel('Hour of the day')
ax[0].set_ylabel('Frequency')

ax[1].scatter(x=data["hour"], y=data["fare_amount"], s=1.5, c="#3D2C05")
ax[1].set_title("Fares by Hour of the day")
ax[1].set_xlabel('Hour of the day')
ax[1].set_ylabel('Fare')

sns.barplot(x="hour", y="fare_amount", data=data, ax=ax[2], color="#fdb813")
ax[2].set_title("Mean Fares by Hour of the day")
ax[2].set_xlabel('Hour of the day')
ax[2].set_ylabel('Mean fare')
plt.show()

plt.figure(figsize=(15,7))
sns.barplot(x='weekday', y="fare_amount", data=data, palette=("#fdb813", "#3D2C05"))
plt.ylim(0, 14)
plt.title("Mean Fares among Days of the week")
plt.xlabel('Day of Week')
plt.ylabel('Mean fare')
plt.show()

f, ax = plt.subplots(1, 2, figsize=(16, 5))
sns.regplot(x="distance", y="fare_amount", data=data, color="#fdb813", ax=ax[0])
sns.regplot(x="distance", y="fare_amount", data=data, color="#fdb813", ax=ax[1])
ax[1].set_xlim(0, 1000)
ax[1].set_ylim(0, 300)
plt.title("Positive relation between distance and fare")
plt.show()

f = plt.figure(figsize=(14, 8))
sns.heatmap(data.corr(), annot=True, linewidths=0.2, cmap="viridis")
plt.title("Correlation Heatmap")
plt.show()

dropoff_longitude = data['dropoff_longitude'].to_numpy()
dropoff_latitude = data['dropoff_latitude'].to_numpy()

plt.figure(figsize=(12,8))
plt.scatter(dropoff_longitude, dropoff_latitude,
                color="#fdb813", 
                s=.02, alpha=.2)
plt.title("Dropoffs through the city")
# Borders of the city
plt.xlim(-74.03, -73.75)
plt.ylim(40.63, 40.85)
plt.show()

data.drop(columns=["key", "pickup_datetime"], inplace=True)
data.head()

y = data["fare_amount"]
train = data.drop(columns=["fare_amount"])

x_train, x_test, y_train, y_test = train_test_split(train, y, random_state=2666, test_size=0.05)

params = {
    "max_depth": 7,
    "subsample": 0.9,
    "eta": 0.03,
    "colsample_bytree": 0.9,
    "random_state": 2666,
    "objective": "reg:linear",
    "eval_metric": "rmse",
    "silent": 1
}

def XGBmodel(x_train, x_test, y_train, y_test, params):
    matrix_train = xgb.DMatrix(x_train, label=y_train)
    matrix_test = xgb.DMatrix(x_test, label=y_test)
    model = xgb.train(params=params,
                      dtrain=matrix_train,num_boost_round=5000, 
                      early_stopping_rounds=10,evals=[(matrix_test,'test')])
    return model

start_time = time.time()
model = XGBmodel(x_train, x_test, y_train, y_test, params)

time_taken = time.time() - start_time
time_taken

test =  pd.read_csv('taxi-fare_submission.csv')
test = datetime_info(test)
test = airport_dist(test)
test['distance'] = sphere_dist(test['pickup_latitude'], test['pickup_longitude'], 
                               test['dropoff_latitude'] , test['dropoff_longitude'])
test_key = test['key']
x_pred = test.drop(columns=['key', 'pickup_datetime']) 

#Predict from test set
prediction = model.predict(xgb.DMatrix(x_pred), ntree_limit=model.best_ntree_limit)

#Create submission file
submission = pd.DataFrame({
        "key": test_key,
        "fare_amount": prediction.round(2)
})

submission.to_csv('taxi_fare_submission.csv',index=False)
submission.head()









